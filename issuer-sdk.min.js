(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
})((function () { 'use strict';

  // JavaScript SDK for Developer API
  // Usage: import sdk from './sdk';

  const API_BASE = '/api/dev';

  class IssuerSDK {
    constructor(apiKey) {
      this.apiKey = apiKey;
    }

    setApiKey(apiKey) {
      this.apiKey = apiKey;
    }

    // Helper for API requests
    async _request(method, path, body) {
      const opts = {
        method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
      };
      if (body) opts.body = JSON.stringify(body);
      const res = await fetch(`${API_BASE}${path}`, opts);
      if (!res.ok) throw new Error(await res.text());
      return res.json();
    }

    // Credentials
    async issueCredential(data) {
      return this._request('POST', '/credentials/issue', data);
    }
    async getCredential(id) {
      return this._request('GET', `/credentials/${id}`);
    }

    // Payments
    async sendPayment(data) {
      return this._request('POST', '/payments/send', data);
    }
    async getWalletBalance() {
      return this._request('GET', '/wallet/balance');
    }

    // Webhooks
    async registerWebhook(data) {
      return this._request('POST', '/webhooks/register', data);
    }
    async getWebhooks() {
      return this._request('GET', '/webhooks');
    }
    async getWebhookLogs() {
      return this._request('GET', '/webhooks/logs');
    }

    // API Keys
    async getApiKeys() {
      return this._request('GET', '/api-keys');
    }
    async createApiKey(data) {
      return this._request('POST', '/api-keys', data);
    }
    async revokeApiKey(data) {
      return this._request('POST', '/api-keys/revoke', data);
    }

    // Usage
    async getUsage() {
      return this._request('GET', '/usage');
    }

    // Webhook listener (polling)
    startWebhookPolling(callback, interval = 5000) {
      if (this._webhookPolling) return;
      this._webhookPolling = true;
      let lastTimestamp = null;
      const poll = async () => {
        if (!this._webhookPolling) return;
        try {
          const logs = await this.getWebhookLogs();
          // Filter new events by timestamp
          const newEvents = logs.filter(e => !lastTimestamp || new Date(e.timestamp) > new Date(lastTimestamp));
          if (newEvents.length > 0) {
            lastTimestamp = newEvents[newEvents.length - 1].timestamp;
            newEvents.forEach(callback);
          }
        } catch (e) {
          // Optionally handle error
        }
        if (this._webhookPolling) {
          this._webhookPollingTimeout = setTimeout(poll, interval);
        }
      };
      poll();
    }

    stopWebhookPolling() {
      this._webhookPolling = false;
      if (this._webhookPollingTimeout) {
        clearTimeout(this._webhookPollingTimeout);
        this._webhookPollingTimeout = null;
      }
    }

    onWebhook(callback, interval) {
      this.startWebhookPolling(callback, interval);
    }
  }

  const sdk = {
    IssuerSDK,
  };

  if (typeof window !== 'undefined') {
    window.sdk = sdk;
  }

}));
//# sourceMappingURL=issuer-sdk.min.js.map
